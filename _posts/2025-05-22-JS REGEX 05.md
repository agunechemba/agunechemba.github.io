# JS REGEX 05: Finding Hidden Patterns in Text with `.exec()` in JavaScript

<img src="https://agunechembaekene.wordpress.com/wp-content/uploads/2025/10/js-regex-1.jpg" width="100%">

Have you ever played a treasure hunt game — where you’re searching through words or numbers, looking for that one hidden clue?
Well, in JavaScript, there’s a magical magnifying glass called **`.exec()`**, and it helps you do exactly that — *hunt for treasures* buried deep inside a string!

Just imagine you’re a code detective with a flashlight, searching for hidden matches, patterns, or clues within lines of text.
That’s what `.exec()` lets you do — it’s your personal pattern-hunting assistant in the world of Regular Expressions.

---

When you use `.exec()`, you’re basically telling JavaScript:

> “Hey, find me something that looks like THIS pattern inside THAT string.”

Let’s take a simple example to see this in action:

```js
var re = /([0-9]+)[a-z]+/;
var match = re.exec("foo123bar");
```

At first glance, this may look mysterious, but it’s actually very logical.
Here’s what’s happening behind the curtain:

* `/([0-9]+)[a-z]+/` is your **pattern** — your treasure map.

  * `([0-9]+)` means “find one or more digits.”
  * `[a-z]+` means “followed by one or more lowercase letters.”
* `"foo123bar"` is your **string** — your treasure field.

When you call `.exec("foo123bar")`, JavaScript begins scanning through the string, letter by letter, looking for anything that matches the pattern you described.

---

And when it finally finds a match, `.exec()` returns a **special array** full of information about that discovery!
It doesn’t just say “Yes, I found it” — it gives you the details.

Here’s what you’ll get:

| Property      | Description                     | Example    |
| ------------- | ------------------------------- | ---------- |
| `match[0]`    | The full matched text           | `"123bar"` |
| `match[1]`    | The first captured group        | `"123"`    |
| `match.index` | The starting index of the match | `3`        |

So in our example, `.exec()` is basically saying:

> “Hey detective! I found something starting at position 3 — it’s ‘123bar’, and the numbers you asked for are ‘123’!”

---

If we visualize what’s happening, it looks something like this:

```
String:   f  o  o  1  2  3  b  a  r
Index:    0  1  2  3  4  5  6  7  8
Match:             1  2  3  b  a  r
                  ^ match starts here (index 3)
```

That’s `.exec()` working like x-ray vision — scanning through the text and reporting back with the exact location and content of what it found. 🔍

---

Now, here’s where things get even more interesting.
What if you don’t just want *one* match?
What if your string contains *many* matches — like every “a” in the word “barbatbaz”?

That’s when `.exec()` joins forces with the **`g` flag** (which stands for *global search*).
Together, they can loop through all matches one by one — patiently finding every treasure in your text.

Let’s try it:

```js
var re = /a/g;
var result;

while ((result = re.exec('barbatbaz')) !== null) {
  console.log("found '" + result[0] + "', next exec starts at index '" + re.lastIndex + "'");
}
```

---

Here’s what’s going on step by step:

1. The pattern `/a/g` means “look for all occurrences of the letter `a`.”
2. `.exec()` finds the first match — then it doesn’t forget where it stopped.
3. It updates the property `re.lastIndex` with the position to resume from next time.
4. The loop continues calling `.exec()` until no more matches are found (which returns `null`).

The output looks like this:

```
found 'a', next exec starts at index '2'
found 'a', next exec starts at index '5'
found 'a', next exec starts at index '8'
```

Each time `.exec()` finds a match, it says,

> “💎 Found an ‘a’ at this spot — I’ll start the next search right after it!”

That’s why I like to say `.exec()` behaves like a **metal detector** on a beach — it beeps whenever it detects a treasure and then moves forward to search for the next one. 🏖️

---

Let’s make it a bit more fun with another example.

Say you want to find all the **capital letters** in a sentence. You can use `.exec()` to detect each one like a secret agent scanning for uppercase clues.

Try this code:

```js
var re = /[A-Z]/g;
var word = "HeLLo World!";
var match;

while ((match = re.exec(word)) !== null) {
  console.log("Found capital letter: " + match[0] + " at position " + match.index);
}
```

When you run it, you’ll see each capital letter and where it appears in the sentence — perfect for case validation or text analysis.

---

Let’s summarize the key ideas before we move on.

| Concept        | Description                                               |
| -------------- | --------------------------------------------------------- |
| `.exec()`      | Searches a string for a pattern and returns match details |
| Returns        | An array with info about the match, or `null` if no match |
| `match[0]`     | Full match found                                          |
| `match[1]`     | Captured group (if parentheses are used)                  |
| `match.index`  | Position where the match begins                           |
| `/pattern/g`   | The `g` flag enables global search (find all matches)     |
| `re.lastIndex` | Keeps track of where the next search should start         |

---

So remember:

* `.test()` gives you a **simple yes or no** (true/false).
* `.exec()` gives you **all the juicy details** about *what* was found, *where*, and *how*.

If `.test()` is your quick “pattern detector,” then `.exec()` is your **pattern investigator** — the one that brings the full report. 🕵️‍♂️

---

### ✅ 10 Review Fill-Gap Questions

Let’s test what you remember! Fill in the blanks 👇

1. The `.exec()` method is used to ______ a string for a pattern.
2. If `.exec()` finds no match, it returns ______.
3. The first element in the result array (`match[0]`) shows the ______ match.
4. To capture part of a pattern, we use ______ in the RegEx.
5. The `g` flag in `/a/g` means ______ search.
6. `match.index` tells us where the match ______.
7. In the RegEx `/([0-9]+)[a-z]+/`, the part `([0-9]+)` captures one or more ______.
8. The property `re.lastIndex` stores the position where the ______ match will start.
9. The data type returned by `.exec()` is an ______ if a match is found.
10. When looping with `.exec()`, we often use the condition `(result = re.exec(string)) !== ______`.
