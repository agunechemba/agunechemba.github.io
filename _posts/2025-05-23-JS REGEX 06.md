# JS REGEX 06: JavaScript‚Äôs Secret Finders ‚Äî `.test()`, `.exec()`, and `.match()`

<img src="https://agunechembaekene.wordpress.com/wp-content/uploads/2025/10/js-regex-1.jpg" width="100%">

When working with text or user input in JavaScript, **Regular Expressions (RegEx)** help you search, match, and extract specific patterns from strings.
But to perform these searches effectively, you need the right **RegEx methods** ‚Äî and that‚Äôs where `.test()`, `.exec()`, and `.match()` come in.

Although these three methods appear similar, they serve **distinct purposes** and return **different types of results**.
Let‚Äôs explore each one step by step.

---

## üß™ 1. The `.test()` Method ‚Äî Quick Pattern Checking

The `.test()` method is the simplest and fastest way to check whether a specific pattern exists within a string.

### **Syntax**

```js
regex.test(string)
```

### **Example**

```js
var re = /cat/;
console.log(re.test("The cat is here"));  // true
console.log(re.test("No animal here"));   // false
```

### **How It Works**

* It checks whether the **pattern** (`/cat/`) appears in the **string**.
* It returns a **boolean**:

  * `true` ‚Üí if a match is found
  * `false` ‚Üí if no match exists

### **When to Use**

Use `.test()` when you only need to confirm the **presence or absence** of a pattern ‚Äî not its position or details.

---

## üì¶ 2. The `.exec()` Method ‚Äî Detailed Pattern Extraction

The `.exec()` method performs a **deeper search**. Instead of returning a simple true or false, it provides **complete information** about the match.

### **Syntax**

```js
regex.exec(string)
```

### **Example**

```js
var re = /c(at)/;
var result = re.exec("The cat is here");

console.log(result[0]);      // "cat"  ‚Üí full match
console.log(result[1]);      // "at"   ‚Üí captured group
console.log(result.index);   // 4      ‚Üí match position
```

### **How It Works**

* `.exec()` scans through the string for the first match.
* It returns an **array** containing:

  * `result[0]` ‚Üí full matched text
  * `result[1]`, `result[2]`, etc. ‚Üí captured groups (if any)
  * `result.index` ‚Üí starting position of the match
* If no match is found, it returns `null`.

### **With the Global Flag (`g`)**

When used with `/g`, `.exec()` can find multiple matches in a loop:

```js
var re = /a/g;
var result;

while ((result = re.exec("banana")) !== null) {
  console.log("Found:", result[0], "at index", result.index);
}
```

This method is ideal for extracting **detailed match data** or **iterating through multiple occurrences** in a string.

---

## üîÅ 3. The `.match()` Method ‚Äî Convenient String-Based Matching

While `.test()` and `.exec()` belong to the **RegEx object**, `.match()` is a **String method** that allows the same kind of pattern searching but from the string side.

### **Syntax**

```js
string.match(regex)
```

### **Example**

```js
var text = "The cat is here";
var result = text.match(/cat/);

console.log(result[0]); // "cat"
```

### **Global Search with `/g`**

Using the global flag returns **all matches** in an array.

```js
var str = "cat, bat, hat";
console.log(str.match(/at/g));  // ["at", "at", "at"]
```

### **Key Points**

* Without `/g`: `.match()` returns **the first match** as an array (like `.exec()`).
* With `/g`: it returns **all matches** as an array of strings, without detailed position info.

### **When to Use**

Use `.match()` when you want a **quick list of all matched items** within a string, especially for display or summary purposes.

---

## üß≠ Choosing the Right Method

To summarize the differences clearly:

**1. `.test()`**

* Returns: `true` or `false`
* Purpose: Check if a match exists
* Use Case: Quick validation checks

**2. `.exec()`**

* Returns: An array (or `null`)
* Purpose: Retrieve detailed match data
* Use Case: Extract information and positions from matches

**3. `.match()`**

* Returns: Array of matches (or `null`)
* Purpose: Find matches from the string perspective
* Use Case: Get all matching substrings in one go

Each method provides a different level of control ‚Äî from simple checks to full pattern analysis.

---

## üí° Practical Example

Let‚Äôs use all three methods on the same string:

```js
var pattern = /cat/g;
var text = "The cat sat on another cat.";

console.log(pattern.test(text));    // true
console.log(pattern.exec(text));    // ["cat", index: 4]
console.log(text.match(pattern));   // ["cat", "cat"]
```

* `.test()` confirms the word exists.
* `.exec()` provides detailed match info.
* `.match()` returns all matching occurrences.

---

## üß© Review ‚Äì Fill in the Gaps

1. The `.test()` method returns either `______` or `______`.
2. `.exec()` provides detailed match information like the full match, captured groups, and the match `______`.
3. To search for all matches, you add the `______` flag to your regular expression.
4. The method `.match()` is called on the `______`, not the regex.
5. `.test()` is best when you only need a simple `______` or `______` answer.
6. The captured parts of a regex can be accessed inside `.exec()` using bracket notation like `result[______]`.
7. When `.exec()` finds a match, it returns an array; if no match, it returns `______`.
8. The `.match()` method can return an `______` of all found matches when used with the global flag.
9. The property `result.index` tells you where the `______` started in the string.
10. All three ‚Äî `.test()`, `.exec()`, and `.match()` ‚Äî are used to `______` for patterns inside strings.
